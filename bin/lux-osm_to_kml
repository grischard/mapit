#!/usr/bin/python
# vim: set fileencoding=utf-8
#
# This script downloads OSM XML from openstreetmap and converts it into KML
# One KML file is generated per canton, each containing all the communes
# Additionally, one more KML file is generated containing the canton.

import xml.sax, urllib, os
from xml.sax.handler import ContentHandler

dir = os.path.dirname(os.path.abspath(__file__))
data_dir = os.path.join(dir, '..', 'data')

# Make sure cache directory exists
try:
    os.mkdir('%s/cache' % data_dir)
except:
    pass

# Read in file matching names to IDs. Distinguish per canton
# as some names are used more than once in Norway, and we reuse the code.
ids = open('%s/luxembourg/ids.csv' % data_dir).readlines()
refs = {}
for row in ids:
    id, name = row.decode('utf-8').strip().split(',')
    if len(id) == 4:
        canton = int(id[0:2])
    else:
        canton = 0
    refs.setdefault(name, {})[canton] = id

# An XML.SAX parser that simple slurps in the XML data and stores it in dictionaries.
class OSM2KML(ContentHandler):
    def __init__(self, *args, **kwargs):
        self.node = {}
        self.way = {}
        self.relation = {}
        self.current = None

    def startElement(self, name, attr):
        if name == 'node':
            self.node[attr["id"]] = (attr["lon"], attr["lat"])
        elif name == 'tag':
            if isinstance(self.current, dict): # Relation
                self.current['tags'][attr['k']] = attr['v']
        elif name == 'way':
            self.current = []
            self.way[attr["id"]] = self.current
        elif name == 'relation':
            self.current = { 'relations': [], 'ways': [], 'nodes': [], 'tags': {} }
            self.relation[attr['id']] = self.current
        elif name == 'nd':
            self.current.append(attr['ref'])
        elif name == 'member':
            self.current['%ss' % attr['type']].append(attr['ref'])

    def way_wkt(self, way_id, reverse=False):
        way = self.way[way_id]
        nodes = [ '%s,%s,0' % self.node[node] for node in way ]
        if reverse: nodes.reverse()
        return ' '.join(nodes)

    def make_wkt(self, relation_id):
        """Given a relation ID that's already parsed, create a WKT of its polygon."""
        first = True
        wkt = ""
        ways = self.relation[relation_id]['ways']
        i = 0
        max = len(ways) * len(ways)
        while ways and i < max:
            way_id = ways.pop(0)
            way = self.way[way_id]
            i += 1
            if first:
                first = False
                start = way[0]
                end = way[-1]
                wkt = self.way_wkt(way_id)
            elif start == way[0]:
                start = way[-1]
                wkt = self.way_wkt(way_id, reverse=True) + ' ' + wkt
            elif start == way[-1]:
                start = way[0]
                wkt = self.way_wkt(way_id) + ' ' + wkt
            elif end == way[0]:
                end = way[-1]
                wkt += ' ' + self.way_wkt(way_id)
            elif end == way[-1]:
                end = way[0]
                wkt += ' ' + self.way_wkt(way_id, reverse=True)
            else:
                ways.append(way_id)
        if wkt: wkt += " %s,%s,0" % self.node[start]
        return wkt

# Fetch something from OSM and store it for later
# XXX The store never expires, have to delete cache manually currently.
base_url = 'http://www.openstreetmap.org/api/0.6/%s/%s%s'
def fetch_from_cache(type, id, full=''):
    if full: full='-full'
    file = '%s/cache/%s-%s%s' % (data_dir, type, id, full)
    if not os.path.exists(file):
        if full: full = '/full'
        f = urllib.urlopen(base_url % (type, id, full))
        r = f.read()
        f.close()
        f = open(file, 'w')
        f.write(r)
        f.close()
    return open(file)

# Lovely magic numbers
relation_ids = {
     0	: 2089832, # Cantons Luxembourg
     1	: 407824,  # Luxembourg 
     2	: 407813,  # Capellen 
     5	: 1115796, # Clervaux 
     6	: 1113683, # Diekirch 
    10	: 407792,  # Echternach 
     3	: 1113898, # Esch-sur-Alzette 
    11	: 407796,  # Grevenmacher 
     4	: 407810,  # Mersch 
     7	: 660245,  # Redange 
    12	: 407799,  # Remich 
     9	: 1342842, # Vianden
     8	: 1115797, # Wiltz
}

# Okay, let's get going
for canton_id, relation_id in relation_ids.items():
    print "Fetching relation %d..." % relation_id
    P = OSM2KML()
    xml.sax.parse( fetch_from_cache('relation', relation_id), P )

    out = open('%s/cache/%02d.kml' % (data_dir, canton_id), 'w')
    out.write('''<?xml version="1.0" encoding="UTF-8"?>
<kml xmlns="http://earth.google.com/kml/2.1">
  <Folder>
    <name>Luxembourg OSM boundaries</name>
''')

    for id in P.relation[str(relation_id)]['relations']:
        xml.sax.parse( fetch_from_cache('relation', id, True), P )
        rel = P.relation[id]

        name = rel['tags'].get('name', '')
        if not name: name = rel['tags']['name:lb']

        ref = rel['tags'].get('ref')

        if not ref: ref = refs[name][canton_id]
        print " ", id, name.encode('utf-8'), ref

        extended = { 'ref': ref, 'osm': id }
        for k in ('name:lb', 'name:de', 'name:fr'):
            if rel['tags'].get(k): extended[k] = rel['tags'].get(k)
        if rel['tags'].get('name:samisk'): extended['name:smi'] = rel['tags'].get('name:samisk')
        extended = '\n        '.join([ '<Data name="%s"><value>%s</value></Data>' % (k,v) for k, v in extended.items() ])

        out.write(('''    <Placemark>
      <name>%s</name>
      <ExtendedData>
        %s
      </ExtendedData>
      <Polygon><outerBoundaryIs><LinearRing><coordinates>''' % (name, extended) ).encode('utf-8') )
        out.write( P.make_wkt(id) )
        out.write('''</coordinates></LinearRing></outerBoundaryIs></Polygon>
    </Placemark>
''')

    out.write('''
  </Folder>
</kml>''')
    out.close()

